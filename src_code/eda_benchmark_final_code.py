# -*- coding: utf-8 -*-
"""EDA_benchmark_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H8VCWsXWmPTMWPNCr4KMND45juEZ58gb
"""

import numpy as np
import heapq
import os
import csv

class GlobalRouter:
    def __init__(self, grid_file, benchmark_name="benchmark", output_file="output.txt", congestion_threshold=7):
        self.grid, self.nets = self.parse_grid(grid_file)
        self.benchmark_name = benchmark_name
        self.congestion = np.zeros(self.grid.shape, dtype=int)
        self.congestion_threshold = congestion_threshold
        self.output_file = output_file
        self.output_lines = []

    def log(self, line):
        print(line)
        self.output_lines.append(line)

    def parse_grid(self, grid_file):
        with open(grid_file, 'r') as f:
            lines = []
            for line in f:
                line = line.split('#')[0].strip()
                if line:
                    lines.append(line)

        width, height = map(int, lines[0].split())
        grid = np.zeros((height, width))

        nets = []
        for line in lines[1:]:
            net = tuple(map(int, line.split()))
            if net[0:2] != net[2:4]:
                nets.append(net)

        return grid, nets

    def heuristic(self, node, target):
        return abs(node[0] - target[0]) + abs(node[1] - target[1])

    def astar_route(self, start, target, avoid_nodes=set()):
        open_list = []
        heapq.heappush(open_list, (0, 0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, target)}
        directions = [(1,1), (-1,-1), (1,-1), (-1,1), (1,0), (0,1), (-1,0), (0,-1)]

        while open_list:
            _, _, current = heapq.heappop(open_list)
            if current == target:
                return self.reconstruct_path(came_from, current)

            for dx, dy in directions:
                neighbor = (current[0] + dx, current[1] + dy)
                if 0 <= neighbor[0] < self.grid.shape[0] and 0 <= neighbor[1] < self.grid.shape[1]:
                    if neighbor in avoid_nodes and self.congestion[neighbor] > self.congestion_threshold:
                        continue

                    is_diagonal = abs(dx) + abs(dy) == 2
                    move_cost = 0.7 if is_diagonal else 1.0
                    congestion_penalty = self.congestion[neighbor] * 0.4
                    manhattan_penalty = self.heuristic(neighbor, target) * 0.2
                    tentative_g = g_score[current] + move_cost + congestion_penalty + manhattan_penalty
                    f = tentative_g + self.heuristic(neighbor, target)

                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g
                        f_score[neighbor] = f
                        heapq.heappush(open_list, (f, -move_cost, neighbor))
        return []

    def reconstruct_path(self, came_from, current):
        path = []
        while current in came_from:
            path.append(current)
            self.congestion[current] += 1
            current = came_from[current]
        path.append(current)
        return path[::-1]

    def identify_congested_nodes(self):
        return {(x, y) for x in range(self.grid.shape[0])
                for y in range(self.grid.shape[1])
                if self.congestion[x, y] > self.congestion_threshold}

    def calculate_congestion_score(self):
        overused = np.sum(self.congestion > self.congestion_threshold)
        avg_cong = np.mean(self.congestion)
        max_cong = np.max(self.congestion)
        return overused, avg_cong, max_cong

    def save_summary_to_csv(self, filename, wirelength_sum, overused, max_cong, avg_cong):
        header = ["Benchmark", "Total Wirelength", "Overused Nodes", "Max Congestion", "Avg Congestion"]
        row = [self.benchmark_name, wirelength_sum, overused, max_cong, f"{avg_cong:.2f}"]

        write_header = not os.path.exists(filename)
        with open(filename, 'a', newline='') as f:
            writer = csv.writer(f)
            if write_header:
                writer.writerow(header)
            writer.writerow(row)

    def route(self):
        reroute_needed = True
        routed_paths = {}
        failed_routes = set()

        while reroute_needed:
            reroute_needed = False
            self.congestion.fill(0)

            for net in self.nets:
                if net in failed_routes:
                    continue
                start, target = (net[0], net[1]), (net[2], net[3])
                path = self.astar_route(start, target)
                if path:
                    routed_paths[net] = path
                else:
                    failed_routes.add(net)

            congested = self.identify_congested_nodes()
            if congested:
                self.log(f"Congested Nodes: {congested}")
                reroute_needed = True
                for net, path in list(routed_paths.items()):
                    if any(node in congested for node in path):
                        start, target = (net[0], net[1]), (net[2], net[3])
                        new_path = self.astar_route(start, target, avoid_nodes=congested)
                        if new_path:
                            routed_paths[net] = new_path
                        else:
                            self.log(f"WARNING: No valid path for {start} -> {target}")
                            failed_routes.add(net)

        total_wirelength = 0
        for net, path in routed_paths.items():
            formatted_path = " -> ".join(map(str, path))
            wirelength = len(path) - 1
            total_wirelength += wirelength
            self.log(f"Routing Path for {net[:2]} -> {net[2:]}:\n{formatted_path}\nTotal Wirelength: {wirelength}\n")

        max_congestion = np.max(self.congestion)
        if max_congestion <= self.congestion_threshold:
            self.log("Congestion: Balanced, no overuse in critical paths.")
        else:
            self.log(f"Congestion: Unbalanced, maximum congestion at {max_congestion}")

        overused, avg_cong, max_cong = self.calculate_congestion_score()
        self.log(f"\n[RESULT] Congestion Summary:")
        self.log(f"  - Overused Nodes: {overused}")
        self.log(f"  - Max Congestion: {max_cong}")
        self.log(f"  - Avg Congestion: {avg_cong:.2f}")

        self.save_summary_to_csv("benchmark_summary_newblue1.csv", total_wirelength, overused, max_cong, avg_cong)

        with open(self.output_file, 'w') as f:
            for line in self.output_lines:
                f.write(line + '\n')

if __name__ == "__main__":
    router = GlobalRouter("newblue1.grid", benchmark_name="newblue1", output_file="output_newblue1.txt")
    router.route()