# -*- coding: utf-8 -*-
"""EDA_project_modify.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wXq2UOOw65KWEHc9vxAucgC_4dS6KVVV
"""

import numpy as np
import heapq

class GlobalRouter:
    def __init__(self, grid_file, congestion_threshold=5):
        self.grid, self.nets = self.parse_grid(grid_file)
        self.congestion = np.zeros(self.grid.shape, dtype=int)
        self.congestion_threshold = congestion_threshold
        self.output_lines = []  # Collect output for file writing

    def parse_grid(self, grid_file):
        with open(grid_file, 'r') as f:
            #lines = f.readlines()
            lines = []
            for line in f:
                # Remove inline comments and strip whitespace
                line = line.split('#')[0].strip()
                if line:
                    lines.append(line)

        width, height = map(int, lines[0].split())
        grid = np.zeros((height, width))
        nets = [tuple(map(int, line.split())) for line in lines[1:]]
        return grid, nets

    def heuristic(self, node, target):
        return abs(node[0] - target[0]) + abs(node[1] - target[1])

    def astar_route(self, start, target, avoid_nodes=set()):
        open_list = []
        heapq.heappush(open_list, (0, 0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, target)}
        directions = [(1,1), (-1,-1), (1,-1), (-1,1), (1,0), (0,1), (-1,0), (0,-1)]

        while open_list:
            _, _, current = heapq.heappop(open_list)
            if current == target:
                return self.reconstruct_path(came_from, current)

            for dx, dy in directions:
                neighbor = (current[0] + dx, current[1] + dy)
                if 0 <= neighbor[0] < self.grid.shape[0] and 0 <= neighbor[1] < self.grid.shape[1]:
                    if neighbor in avoid_nodes and self.congestion[neighbor] > self.congestion_threshold:
                        continue
                    is_diagonal = abs(dx) + abs(dy) == 2
                    move_cost = 0.7 if is_diagonal else 1.0
                    congestion_penalty = self.congestion[neighbor] * 0.4
                    manhattan_penalty = self.heuristic(neighbor, target) * 0.2
                    tentative_g = g_score[current] + move_cost + congestion_penalty + manhattan_penalty
                    f = tentative_g + self.heuristic(neighbor, target)
                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g
                        f_score[neighbor] = f
                        heapq.heappush(open_list, (f, -move_cost, neighbor))
        return []

    def reconstruct_path(self, came_from, current):
        path = []
        while current in came_from:
            path.append(current)
            self.congestion[current] += 1
            current = came_from[current]
        path.append(current)
        return path[::-1]

    def identify_congested_nodes(self):
        return {(x, y) for x in range(self.grid.shape[0])
                        for y in range(self.grid.shape[1])
                        if self.congestion[x, y] > self.congestion_threshold}

    def calculate_congestion_score(self):
        total_nodes = self.congestion.size
        overused_nodes = np.sum(self.congestion > self.congestion_threshold)
        max_cong = np.max(self.congestion)
        avg_cong = np.mean(self.congestion)
        return overused_nodes, max_cong, avg_cong

    def log(self, msg):
        print(msg)
        self.output_lines.append(msg)

    def route(self):
        reroute_needed = True
        routed_paths = {}
        failed_routes = set()

        while reroute_needed:
            reroute_needed = False
            self.congestion.fill(0)

            for net in self.nets:
                if net in failed_routes:
                    continue
                start, target = (net[0], net[1]), (net[2], net[3])
                path = self.astar_route(start, target)
                if path:
                    routed_paths[net] = path
                else:
                    failed_routes.add(net)

            congested = self.identify_congested_nodes()
            if congested:
                self.log(f"\n[INFO] Congested Nodes: {congested}")
                reroute_needed = True
                for net, path in list(routed_paths.items()):
                    if any(node in congested for node in path):
                        start, target = (net[0], net[1]), (net[2], net[3])
                        new_path = self.astar_route(start, target, avoid_nodes=congested)
                        if new_path:
                            routed_paths[net] = new_path
                        else:
                            self.log(f"WARNING: No valid path for {start} -> {target}")
                            failed_routes.add(net)

        for net, path in routed_paths.items():
            formatted_path = " -> ".join(map(str, path))
            wirelength = len(path) - 1
            self.log(f"\nRouting Path for {net[:2]} -> {net[2:]}: \n{formatted_path}\nTotal Wirelength: {wirelength}\n")

        overused, max_cong, avg_cong = self.calculate_congestion_score()
        self.log(f"\n[RESULT] Congestion Summary:")
        self.log(f"  - Overused Nodes: {overused}")
        self.log(f"  - Max Congestion: {max_cong}")
        self.log(f"  - Avg Congestion: {avg_cong:.2f}")

        if max_cong <= self.congestion_threshold:
            self.log("[STATUS] Congestion: Balanced")
        else:
            self.log("[STATUS] Congestion: Unbalanced")

        # Write to output file
        with open("routing_output5.txt", "w") as f:
            f.write("\n".join(self.output_lines))


if __name__ == "__main__":
    router = GlobalRouter("circuit_5.grid")
    router.route()